#!/usr/bin/env python
################################################################################
## holidata.net - date gatherer
##
##    Utility for simplifying the collection of dates for a new year's worth of
##    holidays
##
################################################################################

import argparse
import csv
from collections import defaultdict
from datetime import datetime
from enum import Enum
import logging

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger()


FIXED_DATE = 'F'

HEADINGS = (
    'Locale',
    'Region',
    'Date',
    'Description',
    'Type',
    'Notes',
)


def get_parser():
    parser = argparse.ArgumentParser(
        description='Utility for updating holiday data')
    parser.add_argument('data_file', type=str, help='Path to data file')
    parser.add_argument('new_year', type=int, help='The year to add data for')
    return parser


def read_existing_data(data_file):
    """Load existing data from the specified data file
    We expect the first line in the file to be a commented out header line.
    Dates will be parsed to datetime objects
    """
    holidays = []
    with open(data_file, 'r') as csvfile:
        dialect = csv.Sniffer().sniff(csvfile.read(1024))
        csvfile.seek(0)
        reader = csv.DictReader(csvfile, fieldnames=HEADINGS, dialect=dialect)
        next(reader, None)  # Skip the commented header

        for row in reader:
            row['Date'] = datetime.strptime(row['Date'], '%Y-%m-%d')
            holidays.append(row)

    return holidays


def get_most_recent_year(data):
    """Filter out events for all years but the most recent one"""
    available_years = set()
    for event in data:
        available_years.add(event['Date'].year)

    most_recent_year = sorted(available_years)[-1]

    return [event for event in data if event['Date'].year == most_recent_year]


def events_to_day_mapping(events):
    """Transform events to a mapping of (month, day) -> event

    This allows for grouping of 'duplicate' events across locales and regions
    """
    mapping = defaultdict(list)
    for event in events:
        mapping[(event['Date'].month, event['Date'].day)].append(event)

    return mapping


def is_fixed_date_event(event_instances):
    """Check all instances for the 'Fixed' type

    `event_instances` is a group of event objects that represent the same
    event across multiple locales and regions
    """
    for e in event_instances:
        if FIXED_DATE in e['Type']:
            return True
    return False


def prompt_for_new_date(event_instances):
    """Gather the new month and day for an event"""
    prompt = 'Variable Date Holiday Found\n'
    regions = []
    for event in event_instances:
        regions.append('\t{Locale}/{Region} {Description} {Notes}'.format(**event))
    prompt += '\n'.join(regions)

    print(prompt)
    new_date = input('Input a new date as MM-DD: ')
    print()
    month, day = map(int, new_date.split('-'))
    return month, day


def get_new_date(event_instances):
    """Get the new date for a given grouping of events"""
    if not is_fixed_date_event(event_instances):
        month, day = prompt_for_new_date(event_instances)
    else:
        instance = event_instances[0]['Date']
        month, day = instance.month, instance.day

    return month, day


def get_new_dates(new_year, date_mapping):
    new_holidays = []
    for event_instances in date_mapping.values():
        new_month, new_day = get_new_date(event_instances)
        for e in event_instances:
            e['Date'] = e['Date'].replace(
                year=new_year,
                month=new_month,
                day=new_day)
            new_holidays.append(e)
    return new_holidays


def write_new_events(data_file, event_instances):
    event_instances = sorted(
        event_instances,
        key=lambda h: (h['Locale'], h['Date'], h['Region'])
    )

    with open(data_file, 'a') as csvfile:
        writer = csv.DictWriter(
            csvfile,
            fieldnames=HEADINGS,
            lineterminator='\n',
            quoting=csv.QUOTE_ALL,
        )
        for event in event_instances:
            event['Date'] = event['Date'].strftime('%Y-%m-%d')
            writer.writerow(event)


def main():
    parser = get_parser()
    args = parser.parse_args()

    data = read_existing_data(args.data_file)
    most_recent_year = get_most_recent_year(data)
    date_mapping = events_to_day_mapping(most_recent_year)
    new_holidays = get_new_dates(args.new_year, date_mapping)

    write_new_events(args.data_file, new_holidays)


if __name__ == '__main__':
    main()
